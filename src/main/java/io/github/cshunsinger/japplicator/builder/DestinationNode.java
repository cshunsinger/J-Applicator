package io.github.cshunsinger.japplicator.builder;

import io.github.cshunsinger.asmsauce.code.CodeInsnBuilderLike;
import io.github.cshunsinger.japplicator.annotation.FieldIdentifier;
import io.github.cshunsinger.japplicator.annotation.Nested;
import io.github.cshunsinger.japplicator.util.ReflectionsUtils;
import lombok.AccessLevel;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;

import java.lang.reflect.Field;
import java.lang.reflect.Method;
import java.util.List;
import java.util.Objects;
import java.util.Set;
import java.util.stream.Collectors;
import java.util.stream.Stream;

import static io.github.cshunsinger.asmsauce.code.CodeBuilders.*;
import static io.github.cshunsinger.japplicator.builder.AsmUtils.ILLEGAL_PREFIXES;
import static io.github.cshunsinger.japplicator.builder.AsmUtils.memberIdentifierName;
import static io.github.cshunsinger.japplicator.util.ReflectionsUtils.fieldNameFromMethodName;
import static org.apache.commons.lang3.StringUtils.capitalize;

@Slf4j
@RequiredArgsConstructor(access = AccessLevel.PRIVATE)
public class DestinationNode {
    private final Method setter;
    private final Method getter; //Only non-null when nestedDestinations is non-null
    private final List<DestinationNode> nestedDestinations; //If non-null, there is nesting

    private DestinationNode(Method setter) {
        this(setter, null, null);
    }

    /**
     * Builds the asm code for setting values on the destination object.
     * This method assumes fromVar contains a non-null value obtained from the `source` object (in the generated bytecode).
     * This method also assumes toVar contains a non-null `destination` object (in the generated bytecode).
     *
     * @param toVar The name of the local variable containing the current `destination` object (or nested object)
     * @param fromVar The name of the local variable containing a non-null source value.
     * @return The code to set destination object values.
     */
    public CodeInsnBuilderLike buildDestination(Class<?> fromType, String toVar, String fromVar) {
        if(nestedDestinations != null) {
            //Nested situation
            String nextToVar = toVar + capitalize(fieldNameFromMethodName(getter));

            boolean constructable = AsmUtils.canBeConstructed(getter.getReturnType()) && setter != null;

            List<CodeInsnBuilderLike> nextSteps = nestedDestinations.stream()
                .map(nestedDestination -> nestedDestination.buildDestination(fromType, nextToVar, fromVar))
                .filter(Objects::nonNull)
                .collect(Collectors.toList());

            if(nextSteps.isEmpty())
                return null;

            if(constructable) {
                /*
                 * toVar2 = toVar.getNestedValue();
                 * if(toVar2 == null) {
                 *     toVar2 = new NestedTypeObject();
                 *     toVar.setNestedValue(toVar2);
                 * }
                 * ... do the next steps ...
                 */
                Stream<CodeInsnBuilderLike> currentSteps = Stream.of(
                    //toVar2 = toVar.getNestedValue();
                    setVar(nextToVar, getVar(toVar).invoke(getter.getDeclaringClass(), getter)),
                    //if(toVar2 == null)
                    if_(getVar(nextToVar).isNull()).then(
                        //toVar2 = new NestedTypeObject();
                        setVar(nextToVar, instantiate(getter.getReturnType())),
                        //toVar.setNestedValue(toVar2);
                        getVar(toVar).invoke(setter.getDeclaringClass(), setter, getVar(nextToVar))
                    )
                );

                return block(Stream.concat(currentSteps, nextSteps.stream()).toArray(CodeInsnBuilderLike[]::new));
            }
            else {
                /*
                 * toVar2 = toVar.getNestedValue();
                 * if(toVar2 != null) {
                 *     ... do the next steps ...
                 * }
                 */
                return block(
                    //toVar2 = toVar.getNestedValue();
                    setVar(nextToVar, getVar(toVar).invoke(getter.getDeclaringClass(), getter)),
                    //if(toVar2 != null) {... next steps ...}
                    if_(getVar(nextToVar).isNotNull()).then(
                        nextSteps.toArray(CodeInsnBuilderLike[]::new)
                    )
                );
            }
        }
        else {
            //Non-nested situation
            //toVar.setSomeValue((cast/autoboxed)fromVar);
            Class<?> destType = setter.getParameterTypes()[0];
            CodeInsnBuilderLike convertedSourceValue = ValueConverters.createValueConverter(fromVar, fromType, destType);
            return getVar(toVar).invoke(setter.getDeclaringClass(), setter, convertedSourceValue);
        }
    }

    public static List<DestinationNode> createDestinationsForField(String fieldName, Class<?> type) {
        log.info("Scanning for identified fields identified as {}.", fieldName);

        //The class-level defaults (whether or not all fields are counted)
        FieldIdentifier defaults = type.getAnnotation(FieldIdentifier.class);

        //The methods for accessing fields identified by `fieldName`
        Set<Method> fieldSetters = findFieldSetterMethods(fieldName, type, defaults);
        //The methods annotated as direct accessor methods
        Stream<Method> setterMethods = findIdentifiedSetterMethods(fieldName, type, fieldSetters);

        //Build all of the nodes that directly set a value
        Stream<DestinationNode> directNodes = Stream.concat(fieldSetters.stream(), setterMethods).map(DestinationNode::new);

        //Build all of the nodes that have to call an underlying nested node
        Stream<DestinationNode> nestedNodes = generateNestedNodes(fieldName, type);

        return Stream.concat(directNodes, nestedNodes).collect(Collectors.toList());
    }

    private static Set<Method> findFieldSetterMethods(String fieldName, Class<?> type, FieldIdentifier defaults) {
        return Set.of(type.getDeclaredFields())
            .stream()
            .filter(field -> fieldName.equals(memberIdentifierName(field, defaults)))
            .map(field -> {
                Method fieldAccessor = ReflectionsUtils.findSetterMethodForField(type, field);
                if(fieldAccessor != null)
                    log.info("Found field {} with setter method {}.", field.getName(), fieldAccessor.getName());
                return fieldAccessor;
            })
            .filter(Objects::nonNull)
            .collect(Collectors.toSet());
    }

    private static Stream<Method> findIdentifiedSetterMethods(String fieldName, Class<?> type, Set<Method> fieldSetters) {
        return Stream.of(type.getMethods())
            .filter(method -> fieldName.equals(memberIdentifierName(method, null))) //Defaults do not apply to methods, only fields
            .filter(method -> {
                boolean valid = ReflectionsUtils.isValidSetterMethod(method);
                if(!valid)
                    log.info("Skipping method {} because it is not a valid setter method.", method.getName());
                return valid;
            })
            .filter(method -> !fieldSetters.contains(method)); //Skip method if it was already included as a field accessor
    }

    private static Stream<DestinationNode> generateNestedNodes(String fieldName, Class<?> type) {
        Stream<DestinationNode> nestedFieldNodes = Stream.of(type.getDeclaredFields())
            .filter(field -> field.isAnnotationPresent(Nested.class))
            .map(field -> generateNestedNode(fieldName, type, field))
            .filter(Objects::nonNull);

        Stream<DestinationNode> nestedMethodNodes = findNestedMethods(type)
            .filter(method -> ReflectionsUtils.getInvalidGetterMethodReason(method) == null)
            .map(method -> generateNestedNode(fieldName, type, method))
            .filter(Objects::nonNull);

        return Stream.concat(nestedFieldNodes, nestedMethodNodes);
    }

    private static DestinationNode generateNestedNode(String fieldName, Class<?> type, Method getter) {
        Class<?> nestedType = getter.getReturnType();
        log.info("Found a @Nested getter method named {}. Nested type: {}", getter.getName(), nestedType.getName());

        //Attempt to find a setter method to complement the getter method
        Method setter = findComplimentarySetterMethod(type, getter);
        String setterName = setter != null ? setter.getName() : "null";

        if(setter != null)
            log.info("Found @Nested setter method named {} which complements {}", setterName, getter.getName());
        else
            log.info("No @Nested setter method found to complement {}", getter.getName());

        List<DestinationNode> nestedDestinations = createDestinationsForField(fieldName, nestedType);
        return nestedDestinations == null ? null : new DestinationNode(setter, getter, nestedDestinations);
    }

    private static DestinationNode generateNestedNode(String fieldName, Class<?> type, Field field) {
        //Attempt to find getter method for field. Skip field if getter method not found
        Method getter = ReflectionsUtils.findGetterMethodForField(type, field);
        if(getter == null) {
            log.info("Skipping @Nested field named {} because no getter method was found.", field.getName());
            return null;
        }

        //Grab the setter method if it exists
        Method setter = ReflectionsUtils.findSetterMethodForField(type, field);
        String setterName = setter != null ? setter.getName() : "null";

        //Log the discovery of the nested field
        log.info("Found an @Nested field named {} with getter method {} and setter method {}. Nested type: {}",
            field.getName(), getter.getName(), setterName, getter.getReturnType().getName()
        );

        //Validate that the nested object isn't in the Java standard library
        String packageName = getter.getReturnType().getPackageName();
        if(ILLEGAL_PREFIXES.stream().anyMatch(packageName::startsWith)) {
            log.info("Skipping nested field named {} with getter method {} and setter method {} because {} is part of the Java library.",
                field.getName(), getter.getName(), setterName, getter.getReturnType().getName()
            );
            return null;
        }

        List<DestinationNode> nestedDestinations = createDestinationsForField(fieldName, field.getType());
        return nestedDestinations == null ? null : new DestinationNode(setter, getter, nestedDestinations);
    }

    private static Method findComplimentarySetterMethod(Class<?> type, Method getterMethod) {
        Nested nested = getterMethod.getAnnotation(Nested.class);

        String setterName = getterMethod.getName();
        if(setterName.startsWith("get"))
            setterName = "set" + setterName.substring(3);
        else if(setterName.startsWith("is"))
            setterName = "set" + setterName.substring(2);

        return findNestedMethods(type, getterMethod, setterName, nested.value())
            .filter(method -> ReflectionsUtils.getInvalidSetterMethodReason(method) == null)
            .findFirst()
            .orElse(null);
    }

    private static Stream<Method> findNestedMethods(Class<?> type, Method exclude, String methodName, String nestedValue) {
        return findNestedMethods(type)
            .filter(method -> method != exclude)
            .filter(method -> {
                Nested nested = method.getAnnotation(Nested.class);
                if(nested.value().isBlank())
                    return method.getName().equals(methodName);
                else
                    return nestedValue.equals(nested.value());
            });
    }

    private static Stream<Method> findNestedMethods(Class<?> type) {
        return Stream.of(type.getDeclaredMethods())
            .filter(method -> method.isAnnotationPresent(Nested.class));
    }
}